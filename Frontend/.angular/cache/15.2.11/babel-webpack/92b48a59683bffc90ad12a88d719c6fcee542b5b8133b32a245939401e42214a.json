{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// array in local storage for accounts\nconst accountsKey = 'request-management-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n// array in local storage for employees\nconst employeesKey = 'request-management-employees';\nlet employees = JSON.parse(localStorage.getItem(employeesKey)) || [];\n// array in local storage for departments\nconst departmentsKey = 'request-management-departments';\nlet departments = JSON.parse(localStorage.getItem(departmentsKey)) || [{\n  id: 1,\n  name: 'HR',\n  description: 'Human Resources'\n}, {\n  id: 2,\n  name: 'IT',\n  description: 'Information Technology'\n}, {\n  id: 3,\n  name: 'Finance',\n  description: 'Finance Department'\n}, {\n  id: 4,\n  name: 'Marketing',\n  description: 'Marketing Department'\n}];\n// array in local storage for requests and their items\nconst requestsKey = 'request-management-requests';\nlet requests = JSON.parse(localStorage.getItem(requestsKey)) || [];\n// array in local storage for request items\nconst requestItemsKey = 'request-management-items';\nlet requestItems = JSON.parse(localStorage.getItem(requestItemsKey)) || [];\n// array in local storage for workflows\nconst workflowsKey = 'request-management-workflows';\nlet workflows = JSON.parse(localStorage.getItem(workflowsKey)) || [];\n// array in local storage for employee positions\nconst positionsKey = 'request-management-positions';\nlet positions = JSON.parse(localStorage.getItem(positionsKey)) || [{\n  id: 1,\n  name: 'Manager',\n  description: 'Department Manager'\n}, {\n  id: 2,\n  name: 'Team Lead',\n  description: 'Team Leader'\n}, {\n  id: 3,\n  name: 'Senior Staff',\n  description: 'Senior Level Staff'\n}, {\n  id: 4,\n  name: 'Junior Staff',\n  description: 'Junior Level Staff'\n}];\n// array in local storage for request types\nconst requestTypesKey = 'request-management-request-types';\nlet requestTypes = JSON.parse(localStorage.getItem(requestTypesKey)) || [{\n  id: 1,\n  name: 'Leave Request',\n  description: 'Request for leave or time off'\n}, {\n  id: 2,\n  name: 'Equipment Request',\n  description: 'Request for office equipment'\n}, {\n  id: 3,\n  name: 'Training Request',\n  description: 'Request for training or workshops'\n}, {\n  id: 4,\n  name: 'Other',\n  description: 'Other types of requests'\n}];\n// Helper functions for generating IDs\nfunction newAccountId() {\n  return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n}\nfunction newRequestId() {\n  return requests.length ? Math.max(...requests.map(x => x.id)) + 1 : 1;\n}\nfunction newRequestItemId() {\n  return requestItems.length ? Math.max(...requestItems.map(x => x.id)) + 1 : 1;\n}\nfunction newEmployeeId() {\n  return employees.length ? Math.max(...employees.map(x => x.id)) + 1 : 1;\n}\nfunction newWorkflowId() {\n  return workflows.length ? Math.max(...workflows.map(x => x.id)) + 1 : 1;\n}\nfunction newDepartmentId() {\n  return departments.length ? Math.max(...departments.map(x => x.id)) + 1 : 1;\n}\nfunction newPositionId() {\n  return positions.length ? Math.max(...positions.map(x => x.id)) + 1 : 1;\n}\nfunction newRequestTypeId() {\n  return requestTypes.length ? Math.max(...requestTypes.map(x => x.id)) + 1 : 1;\n}\n// Helper functions for JWT and refresh tokens\nfunction generateJwtToken(account) {\n  try {\n    const header = btoa(JSON.stringify({\n      alg: 'HS256',\n      typ: 'JWT'\n    }));\n    const now = new Date().getTime();\n    const payload = {\n      id: account.id,\n      role: account.role,\n      email: account.email,\n      iat: now,\n      exp: now + 60 * 60 * 1000 // 1 hour expiry\n    };\n\n    const payloadBase64 = btoa(JSON.stringify(payload));\n    const signature = btoa('YOUR_FAKE_JWT_SECRET_KEY');\n    return `${header}.${payloadBase64}.${signature}`;\n  } catch (error) {\n    console.error('Error generating JWT token:', error);\n    throw error;\n  }\n}\nfunction generateRefreshToken() {\n  try {\n    const header = btoa(JSON.stringify({\n      alg: 'HS256',\n      typ: 'JWT'\n    }));\n    const now = new Date().getTime();\n    const payload = {\n      id: Math.random().toString(36).substr(2),\n      iat: now,\n      exp: now + 7 * 24 * 60 * 60 * 1000 // 7 days expiry\n    };\n\n    const payloadBase64 = btoa(JSON.stringify(payload));\n    const signature = btoa('YOUR_FAKE_REFRESH_TOKEN_SECRET');\n    return `${header}.${payloadBase64}.${signature}`;\n  } catch (error) {\n    console.error('Error generating refresh token:', error);\n    throw error;\n  }\n}\nfunction isTokenExpired(token) {\n  // PATCH: Always return false so tokens never expire in development\n  return false;\n}\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      // Helper functions\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        }));\n      }\n      function error(message) {\n        return throwError(() => ({\n          error: {\n            message\n          }\n        }));\n      }\n      function unauthorized() {\n        return throwError(() => ({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }));\n      }\n      function notFound() {\n        return throwError(() => ({\n          status: 404,\n          error: {\n            message: 'Not Found'\n          }\n        }));\n      }\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          status,\n          isVerified\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          status,\n          isVerified\n        };\n      }\n      function isAuthenticated() {\n        try {\n          const authHeader = headers.get('Authorization');\n          if (!(authHeader === null || authHeader === void 0 ? void 0 : authHeader.startsWith('Bearer '))) return false;\n          const token = authHeader.split(' ')[1];\n          if (isTokenExpired(token)) {\n            console.log('JWT token has expired');\n            return false;\n          }\n          const parts = token.split('.');\n          const payload = JSON.parse(atob(parts[1]));\n          const account = accounts.find(x => x.id === payload.id);\n          return !!account;\n        } catch (error) {\n          console.error('Authentication check error:', error);\n          return false;\n        }\n      }\n      function isAdmin() {\n        var _a;\n        return ((_a = currentAccount()) === null || _a === void 0 ? void 0 : _a.role) === Role.Admin;\n      }\n      function currentAccount() {\n        if (!isAuthenticated()) return null;\n        try {\n          const token = headers.get('Authorization').split(' ')[1];\n          const parts = token.split('.');\n          const payload = JSON.parse(atob(parts[1]));\n          return accounts.find(x => x.id === payload.id);\n        } catch (_a) {\n          return null;\n        }\n      }\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        // For URLs like /workflows/123/status or /requests/123/status, we want the ID (123)\n        if (urlParts.length > 0) {\n          // If the URL has a path segment after the ID (like 'status')\n          if (urlParts[urlParts.length - 1] === 'status') {\n            // Return the ID which is the segment before 'status'\n            return parseInt(urlParts[urlParts.length - 2]);\n          }\n        }\n        // Default to last part (normal case)\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n      function getRefreshToken(headers) {\n        try {\n          const authHeader = headers.get('Authorization');\n          if (!(authHeader === null || authHeader === void 0 ? void 0 : authHeader.startsWith('Bearer '))) return null;\n          return authHeader.split(' ')[1];\n        } catch (_a) {\n          return null;\n        }\n      }\n      function getWorkflowsByEmployeeId() {\n        if (!isAuthenticated()) return unauthorized();\n        const employeeId = parseInt(url.split('/').pop());\n        console.log('Looking for workflows with employeeId:', employeeId);\n        // Check if employee exists\n        const employee = employees.find(e => e.id === employeeId);\n        if (!employee) {\n          console.log('Employee not found with ID:', employeeId);\n          return notFound();\n        }\n        // Filter workflows by employee ID\n        const employeeWorkflows = workflows.filter(x => x.employeeId === employeeId);\n        console.log('Found workflows for employee:', employeeWorkflows.length);\n        // Sort workflows in descending order by creation date\n        const sortedWorkflows = [...employeeWorkflows].sort((a, b) => {\n          const dateA = new Date(a.datetimecreated || a.createdDate);\n          const dateB = new Date(b.datetimecreated || b.createdDate);\n          return dateB.getTime() - dateA.getTime();\n        });\n        return ok(sortedWorkflows.map(workflow => {\n          // Get associated request if it exists\n          const request = workflow.requestId ? requests.find(r => r.id === workflow.requestId) : null;\n          // Format details appropriately with request number if available\n          let details = '';\n          if (typeof workflow.details === 'object') {\n            details = workflow.details.task || '';\n            if (workflow.details.additionalInfo) {\n              details += ` - ${workflow.details.additionalInfo}`;\n            }\n          } else {\n            details = workflow.details || '';\n          }\n          // Replace placeholders in details if needed\n          if (request && details.includes('#')) {\n            details = details.replace(/#(\\d+)/g, `#${request.id}`);\n          }\n          return {\n            id: workflow.id.toString(),\n            type: workflow.type,\n            details: details,\n            status: workflow.status,\n            datetimecreated: workflow.datetimecreated || workflow.createdDate,\n            requestId: workflow.requestId ? workflow.requestId.toString() : null,\n            employee: {\n              id: employee.id,\n              employeeId: employee.employeeId,\n              name: getEmployeeName(employee)\n            }\n          };\n        }));\n      }\n      // Helper function to get employee name from their account\n      function getEmployeeName(employee) {\n        const account = accounts.find(a => a.id === employee.accountId);\n        if (!account) return 'Unknown';\n        const firstName = account.firstName ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n        const lastName = account.lastName ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n        return `${firstName} ${lastName}`.trim();\n      }\n      return handleRoute().pipe(delay(500), materialize(), dematerialize());\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n          case url.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n          case url.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n          case url.endsWith('/accounts/register') && method === 'POST':\n            return register();\n          case url.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n          case url.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n          case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n          case url.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n          case url.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n          // request routes\n          case url.endsWith('/requests') && method === 'GET':\n            return getRequests();\n          case url.match(/\\/requests\\/\\d+$/) && method === 'GET':\n            return getRequestById();\n          case url.match(/\\/requests\\/employee\\/\\d+$/) && method === 'GET':\n            return getRequestsByEmployeeId();\n          case url.endsWith('/requests/my-requests') && method === 'GET':\n            return getMyRequests();\n          case url.endsWith('/requests') && method === 'POST':\n            return createRequest();\n          case url.match(/\\/requests\\/\\d+$/) && method === 'PUT':\n            return updateRequest();\n          case url.match(/\\/requests\\/\\d+\\/status$/) && method === 'PUT':\n            return changeRequestStatus();\n          case url.match(/\\/requests\\/\\d+$/) && method === 'DELETE':\n            return deleteRequest();\n          // employee routes\n          case url.endsWith('/employees') && method === 'GET':\n            return getEmployees();\n          case url.match(/\\/employees\\/\\d+$/) && method === 'GET':\n            return getEmployeeById();\n          case url.endsWith('/employees') && method === 'POST':\n            return createEmployee();\n          case url.match(/\\/employees\\/\\d+$/) && method === 'PUT':\n            return updateEmployee();\n          case url.match(/\\/employees\\/\\d+$/) && method === 'DELETE':\n            return deleteEmployee();\n          case url.match(/\\/employees\\/\\d+\\/transfer$/) && method === 'PUT':\n            return transferEmployee();\n          // department routes\n          case url.endsWith('/departments') && method === 'GET':\n            return getDepartments();\n          case url.match(/\\/departments\\/\\d+$/) && method === 'GET':\n            return getDepartmentById();\n          case url.endsWith('/departments') && method === 'POST':\n            return createDepartment();\n          case url.match(/\\/departments\\/\\d+$/) && method === 'PUT':\n            return updateDepartment();\n          case url.match(/\\/departments\\/\\d+$/) && method === 'DELETE':\n            return deleteDepartment();\n          // position routes\n          case url.endsWith('/positions') && method === 'GET':\n            return getPositions();\n          case url.match(/\\/positions\\/\\d+$/) && method === 'GET':\n            return getPositionById();\n          case url.endsWith('/positions') && method === 'POST':\n            return createPosition();\n          case url.match(/\\/positions\\/\\d+$/) && method === 'PUT':\n            return updatePosition();\n          case url.match(/\\/positions\\/\\d+$/) && method === 'DELETE':\n            return deletePosition();\n          // request type routes\n          case url.endsWith('/request-types') && method === 'GET':\n            return getRequestTypes();\n          case url.match(/\\/request-types\\/\\d+$/) && method === 'GET':\n            return getRequestTypeById();\n          case url.endsWith('/request-types') && method === 'POST':\n            return createRequestType();\n          case url.match(/\\/request-types\\/\\d+$/) && method === 'PUT':\n            return updateRequestType();\n          case url.match(/\\/request-types\\/\\d+$/) && method === 'DELETE':\n            return deleteRequestType();\n          // workflow routes\n          case url.endsWith('/workflows') && method === 'GET':\n            return getWorkflows();\n          case url.match(/\\/workflows\\/\\d+$/) && method === 'GET':\n            return getWorkflowById();\n          case url.match(/\\/workflows\\/employee\\/\\d+$/) && method === 'GET':\n            return getWorkflowsByEmployeeId();\n          case url.match(/\\/workflows\\/request\\/\\d+$/) && method === 'GET':\n            return getWorkflowsByRequestId();\n          case url.endsWith('/workflows') && method === 'POST':\n            return createWorkflow();\n          case url.match(/\\/workflows\\/\\d+$/) && method === 'PUT':\n            return updateWorkflow();\n          case url.match(/\\/workflows\\/\\d+\\/status$/) && method === 'PUT':\n            return updateWorkflowStatus();\n          case url.match(/\\/workflows\\/\\d+$/) && method === 'DELETE':\n            return deleteWorkflow();\n          case url.match(/\\/workflows\\/items\\/\\d+$/) && method === 'DELETE':\n            return deleteWorkflowItem();\n          default:\n            return next.handle(request);\n        }\n      }\n      // Authentication functions\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        if (!account) return error('Email or password is incorrect');\n        if (password !== account.password) return error('Email or password is incorrect');\n        // PATCH: Auto-activate inactive accounts for development\n        if (account.status === 'Inactive') {\n          account.status = 'Active';\n          localStorage.setItem(accountsKey, JSON.stringify(accounts));\n          console.log('Account automatically activated for testing');\n        }\n        // PATCH: Bypass verification check for development\n        // if (!account.isVerified) {\n        //     ...\n        //     return error('Please verify your email before logging in');\n        // }\n        try {\n          // Generate refresh token that expires in 7 days\n          const refreshToken = generateRefreshToken();\n          account.refreshTokens = account.refreshTokens || [];\n          // Remove any expired refresh tokens\n          account.refreshTokens = account.refreshTokens.filter(rt => !isTokenExpired(rt));\n          account.refreshTokens.push(refreshToken);\n          localStorage.setItem(accountsKey, JSON.stringify(accounts));\n          const jwtToken = generateJwtToken(account);\n          return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n            jwtToken,\n            refreshToken\n          }));\n        } catch (error) {\n          console.error('Authentication error:', error);\n          return error('An error occurred during authentication');\n        }\n      }\n      function refreshToken() {\n        try {\n          const refreshToken = getRefreshToken(headers);\n          if (!refreshToken) {\n            console.log('No refresh token found');\n            return unauthorized();\n          }\n          const account = accounts.find(x => {\n            var _a;\n            return (_a = x.refreshTokens) === null || _a === void 0 ? void 0 : _a.includes(refreshToken);\n          });\n          if (!account) {\n            console.log('No account found for refresh token');\n            return unauthorized();\n          }\n          // PATCH: Auto-activate inactive accounts for development\n          if (account.status === 'Inactive') {\n            account.status = 'Active';\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n            console.log('Account automatically activated during token refresh');\n          }\n          // Verify refresh token hasn't expired\n          if (isTokenExpired(refreshToken)) {\n            console.log('Refresh token has expired');\n            // Remove expired refresh token\n            account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\n            return unauthorized();\n          }\n          // Generate new tokens\n          const newRefreshToken = generateRefreshToken();\n          const jwtToken = generateJwtToken(account);\n          // Update refresh tokens\n          account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken && !isTokenExpired(x));\n          account.refreshTokens.push(newRefreshToken);\n          localStorage.setItem(accountsKey, JSON.stringify(accounts));\n          console.log('Token refresh successful');\n          return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n            jwtToken,\n            refreshToken: newRefreshToken\n          }));\n        } catch (error) {\n          console.error('Refresh token error:', error);\n          return unauthorized();\n        }\n      }\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken(headers);\n        const account = accounts.find(x => {\n          var _a;\n          return (_a = x.refreshTokens) === null || _a === void 0 ? void 0 : _a.includes(refreshToken);\n        });\n        // revoke token and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function register() {\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          // display email already registered message in alert\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div>\n                        <strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.\n                        </div>\n                    `, {\n              autoclose: false\n            });\n          }, 1000);\n          // always return ok() response to prevent email enumeration\n          return ok();\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        if (account.id === 1) {\n          // first registered account is an admin\n          account.role = Role.Admin;\n          account.status = 'Active'; // Admin accounts get active status\n        } else {\n          account.role = Role.User;\n          account.status = 'Active'; // Set all accounts to active for testing\n        }\n\n        account.dateCreated = new Date().toISOString();\n        account.verificationToken = new Date().getTime().toString();\n        account.isVerified = false;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display verification email in alert\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n          alertService.info(`\n                    <h4>Verification Email</h4>\n                    <p>Thanks for registering!</p>\n                    <p>Please click the below link to verify your email address:</p>\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                `, {\n            autoclose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n        if (!account) return error('Verification failed');\n        // set is verified flag to true if token is valid\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can get own profile and admin accounts can get all profiles\n        if (account.id !== currentAccount().id && !isAdmin()) {\n          return unauthorized();\n        }\n        return ok(basicDetails(account));\n      }\n      // Request functions\n      function getRequests() {\n        if (!isAuthenticated()) return unauthorized();\n        // Return all requests for admins, or filtered for regular users\n        let filteredRequests = [...requests];\n        if (!isAdmin()) {\n          const currentUserId = currentAccount().id;\n          filteredRequests = requests.filter(x => x.employeeId === currentUserId);\n        }\n        return ok(filteredRequests.map(request => {\n          const items = requestItems.filter(item => item.requestId === request.id);\n          const requestEmployee = employees.find(e => e.id === request.employeeId);\n          const requestAccount = accounts.find(a => a.id === (requestEmployee === null || requestEmployee === void 0 ? void 0 : requestEmployee.accountId));\n          const requestType = requestTypes.find(t => t.id === request.typeId);\n          return {\n            id: request.id,\n            employeeId: (requestEmployee === null || requestEmployee === void 0 ? void 0 : requestEmployee.employeeId) || '',\n            type: (requestType === null || requestType === void 0 ? void 0 : requestType.name) || request.type || '',\n            status: request.status,\n            createdDate: request.createdDate,\n            items: items,\n            employee: {\n              id: requestEmployee === null || requestEmployee === void 0 ? void 0 : requestEmployee.id,\n              employeeId: requestEmployee === null || requestEmployee === void 0 ? void 0 : requestEmployee.employeeId,\n              fullName: requestAccount ? `${requestAccount.firstName} ${requestAccount.lastName}`.trim() : ''\n            }\n          };\n        }));\n      }\n      function getRequestById() {\n        if (!isAuthenticated()) return unauthorized();\n        const requestId = idFromUrl();\n        console.log('Looking for request with ID:', requestId);\n        const request = requests.find(x => x.id === requestId);\n        if (!request) {\n          console.error('Request not found with ID:', requestId);\n          return notFound();\n        }\n        // Get the current account and check if this is the user's own request\n        const account = currentAccount();\n        // Find if the current user is associated with an employee\n        const userEmployee = employees.find(e => e.accountId === account.id);\n        // Check authorization - admin can see all, users can only see their own\n        const isAdmin = account.role === Role.Admin;\n        const isModerator = account.role === Role.Moderator;\n        const isOwner = userEmployee && userEmployee.id === request.employeeId;\n        if (!isAdmin && !isModerator && !isOwner) {\n          console.error('Unauthorized access to request. User:', account.id, 'Request employeeId:', request.employeeId);\n          return unauthorized();\n        }\n        // Add related data\n        const items = requestItems.filter(item => item.requestId === request.id);\n        const employee = employees.find(e => e.id === request.employeeId);\n        const employeeAccount = accounts.find(a => a.id === (employee === null || employee === void 0 ? void 0 : employee.accountId));\n        const requestType = requestTypes.find(t => t.id === request.typeId);\n        // Format employee name with proper capitalization\n        const firstName = (employeeAccount === null || employeeAccount === void 0 ? void 0 : employeeAccount.firstName) ? employeeAccount.firstName.charAt(0).toUpperCase() + employeeAccount.firstName.slice(1).toLowerCase() : '';\n        const lastName = (employeeAccount === null || employeeAccount === void 0 ? void 0 : employeeAccount.lastName) ? employeeAccount.lastName.charAt(0).toUpperCase() + employeeAccount.lastName.slice(1).toLowerCase() : '';\n        const fullName = `${firstName} ${lastName}`.trim();\n        const result = Object.assign(Object.assign({}, request), {\n          items: items.map(item => ({\n            id: item.id,\n            name: item.name,\n            quantity: item.quantity\n          })),\n          employee: employee ? Object.assign(Object.assign({}, employee), {\n            fullName: fullName,\n            employeeId: employee.employeeId\n          }) : null,\n          type: (requestType === null || requestType === void 0 ? void 0 : requestType.name) || request.type\n        });\n        console.log('Request found and returned:', result.id);\n        return ok(result);\n      }\n      function getRequestsByEmployeeId() {\n        if (!isAuthenticated()) return unauthorized();\n        const internalId = parseInt(url.split('/').pop());\n        console.log('Looking for requests with employeeId:', internalId);\n        const employee = employees.find(e => e.id === internalId);\n        if (!employee) {\n          console.log('Employee not found with internal id:', internalId);\n          return notFound();\n        }\n        const employeeRequests = requests.filter(x => x.employeeId === employee.id);\n        console.log('Found requests:', employeeRequests.length);\n        // Sort requests in descending order by creation date\n        const sortedRequests = [...employeeRequests].sort((a, b) => {\n          const dateA = new Date(a.createdDate);\n          const dateB = new Date(b.createdDate);\n          return dateB.getTime() - dateA.getTime();\n        });\n        return ok(sortedRequests.map(request => {\n          const items = requestItems.filter(item => item.requestId === request.id);\n          const requestType = requestTypes.find(t => t.id === request.typeId);\n          const account = accounts.find(a => a.id === employee.accountId);\n          // Format employee name with proper capitalization\n          const firstName = (account === null || account === void 0 ? void 0 : account.firstName) ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n          const lastName = (account === null || account === void 0 ? void 0 : account.lastName) ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n          const fullName = `${firstName} ${lastName}`.trim();\n          return {\n            id: request.id,\n            type: (requestType === null || requestType === void 0 ? void 0 : requestType.name) || request.type,\n            status: request.status,\n            createdDate: request.createdDate,\n            items: items,\n            employee: {\n              id: employee.id,\n              employeeId: employee.employeeId,\n              fullName: fullName\n            }\n          };\n        }));\n      }\n      function getMyRequests() {\n        if (!isAuthenticated()) return unauthorized();\n        const currentUserId = currentAccount().id;\n        const myRequests = requests.filter(x => x.employeeId === currentUserId);\n        return ok(myRequests.map(request => {\n          const items = requestItems.filter(item => item.requestId === request.id);\n          const employee = employees.find(e => e.id === request.employeeId);\n          const account = accounts.find(a => a.id === (employee === null || employee === void 0 ? void 0 : employee.accountId));\n          const requestType = requestTypes.find(t => t.id === request.typeId);\n          return Object.assign(Object.assign({}, request), {\n            items,\n            employee: employee ? Object.assign(Object.assign({}, employee), {\n              fullName: `${(account === null || account === void 0 ? void 0 : account.firstName) || ''} ${(account === null || account === void 0 ? void 0 : account.lastName) || ''}`.trim(),\n              employeeId: employee.employeeId\n            }) : null,\n            type: requestType ? requestType.name : request.type\n          });\n        }));\n      }\n      function createRequest() {\n        if (!isAuthenticated()) return unauthorized();\n        console.log('Received request data:', body);\n        // Find employee by employeeId\n        let targetEmployee;\n        if (body.employeeId) {\n          // Try to find by internal ID first\n          const employeeIdNum = Number(body.employeeId);\n          targetEmployee = employees.find(e => e.id === employeeIdNum);\n          if (!targetEmployee) {\n            // If not found by internal ID, try to find by employee ID string\n            targetEmployee = employees.find(e => e.employeeId === body.employeeId);\n          }\n          if (!targetEmployee) {\n            console.error('Employee not found for ID:', body.employeeId);\n            return error('Employee not found');\n          }\n        } else {\n          // If no employeeId provided, use current user\n          const currentUser = currentAccount();\n          targetEmployee = employees.find(e => e.accountId === currentUser.id);\n          if (!targetEmployee) {\n            console.error('No employee found for current user');\n            return error('Current user is not an employee');\n          }\n        }\n        console.log('Target employee found:', targetEmployee);\n        const requestId = newRequestId();\n        const request = {\n          id: requestId,\n          employeeId: targetEmployee.id,\n          typeId: body.typeId ? Number(body.typeId) : null,\n          type: body.type,\n          description: body.description || '',\n          status: 'Pending',\n          createdDate: new Date().toISOString(),\n          lastModifiedDate: new Date().toISOString()\n        };\n        console.log('Creating request:', request);\n        // Validate required fields\n        if (!request.type && !request.typeId) {\n          return error('Request type is required');\n        }\n        // Validate and process items if present\n        let requestItemsList = [];\n        if (body.items && Array.isArray(body.items)) {\n          try {\n            requestItemsList = body.items.map(item => {\n              if (!item.name || !item.quantity) {\n                throw new Error('Invalid item data');\n              }\n              return {\n                id: newRequestItemId(),\n                requestId: request.id,\n                name: item.name,\n                quantity: Number(item.quantity)\n              };\n            });\n          } catch (error) {\n            return error('Invalid item data provided');\n          }\n        }\n        // Save request and items\n        requests.push(request);\n        if (requestItemsList.length > 0) {\n          requestItems.push(...requestItemsList);\n          localStorage.setItem(requestItemsKey, JSON.stringify(requestItems));\n        }\n        localStorage.setItem(requestsKey, JSON.stringify(requests));\n        // Get employee and account data for response and workflow\n        const employeeAccount = accounts.find(a => a.id === targetEmployee.accountId);\n        const firstName = (employeeAccount === null || employeeAccount === void 0 ? void 0 : employeeAccount.firstName) ? employeeAccount.firstName.charAt(0).toUpperCase() + employeeAccount.firstName.slice(1).toLowerCase() : '';\n        const lastName = (employeeAccount === null || employeeAccount === void 0 ? void 0 : employeeAccount.lastName) ? employeeAccount.lastName.charAt(0).toUpperCase() + employeeAccount.lastName.slice(1).toLowerCase() : '';\n        const fullName = `${firstName} ${lastName}`.trim();\n        // Get department for workflow\n        const department = departments.find(d => d.id === targetEmployee.departmentId);\n        // Create workflow entry for the request\n        const workflow = {\n          id: newWorkflowId(),\n          employeeId: targetEmployee.id,\n          requestId: request.id,\n          type: 'Request',\n          details: {\n            task: `Request #${request.id} submitted by ${fullName}`,\n            additionalInfo: `${request.type} request submitted by ${targetEmployee.employeeId} from ${department ? department.name : 'unknown'} department`\n          },\n          status: 'Pending',\n          datetimecreated: request.createdDate,\n          lastModifiedDate: request.lastModifiedDate\n        };\n        workflows.push(workflow);\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        const response = Object.assign(Object.assign({}, request), {\n          items: requestItemsList,\n          employee: {\n            id: targetEmployee.id,\n            employeeId: targetEmployee.employeeId,\n            fullName: fullName\n          }\n        });\n        console.log('Created request:', response);\n        return ok(response);\n      }\n      function updateRequest() {\n        if (!isAuthenticated()) return unauthorized();\n        console.log('Received update data:', body);\n        const requestId = idFromUrl();\n        const request = requests.find(x => x.id === requestId);\n        if (!request) return notFound();\n        if (request.employeeId !== currentAccount().id && !isAdmin()) return unauthorized();\n        // Update basic request fields\n        Object.assign(request, {\n          type: body.type,\n          description: body.description || request.description,\n          lastModifiedDate: new Date().toISOString()\n        });\n        // Handle item changes\n        if (body.items) {\n          // Remove all existing items for this request\n          requestItems = requestItems.filter(item => item.requestId !== requestId);\n          // Add new/updated items\n          const newItems = body.items.map(item => ({\n            id: item.id || newRequestItemId(),\n            requestId: requestId,\n            name: item.name,\n            quantity: Number(item.quantity)\n          }));\n          requestItems.push(...newItems);\n          localStorage.setItem(requestItemsKey, JSON.stringify(requestItems));\n        }\n        localStorage.setItem(requestsKey, JSON.stringify(requests));\n        // Get related data for response\n        const employee = employees.find(e => e.id === request.employeeId);\n        const account = accounts.find(a => a.id === (employee === null || employee === void 0 ? void 0 : employee.accountId));\n        const firstName = (account === null || account === void 0 ? void 0 : account.firstName) ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n        const lastName = (account === null || account === void 0 ? void 0 : account.lastName) ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n        const fullName = `${firstName} ${lastName}`.trim();\n        return ok(Object.assign(Object.assign({}, request), {\n          items: requestItems.filter(item => item.requestId === requestId),\n          employee: employee ? Object.assign(Object.assign({}, employee), {\n            fullName: fullName,\n            employeeId: employee.employeeId\n          }) : null\n        }));\n      }\n      function changeRequestStatus() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const requestId = idFromUrl();\n        const request = requests.find(x => x.id === requestId);\n        if (!request) {\n          console.error('Request not found with ID:', requestId);\n          return notFound();\n        }\n        const newStatus = body.status;\n        if (!newStatus) return error('Status is required');\n        console.log('Changing request status from', request.status, 'to', newStatus);\n        // Update request\n        request.status = newStatus;\n        request.lastModifiedDate = new Date().toISOString();\n        // Update requests array\n        const requestIndex = requests.findIndex(x => x.id === requestId);\n        requests[requestIndex] = request;\n        localStorage.setItem(requestsKey, JSON.stringify(requests));\n        // Get related data for response\n        const employee = employees.find(e => e.id === request.employeeId);\n        const account = accounts.find(a => a.id === (employee === null || employee === void 0 ? void 0 : employee.accountId));\n        const requestType = requestTypes.find(t => t.id === request.typeId);\n        const items = requestItems.filter(item => item.requestId === request.id);\n        // Format employee name\n        const firstName = (account === null || account === void 0 ? void 0 : account.firstName) ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n        const lastName = (account === null || account === void 0 ? void 0 : account.lastName) ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n        const fullName = `${firstName} ${lastName}`.trim();\n        // Create workflow entry for status change\n        const adminAccount = currentAccount();\n        const adminName = `${adminAccount.firstName} ${adminAccount.lastName}`;\n        const workflow = {\n          id: newWorkflowId(),\n          employeeId: employee.id,\n          requestId: requestId,\n          type: 'Status Change',\n          details: {\n            task: `Request #${requestId} status changed to ${newStatus}`,\n            additionalInfo: `Request from ${employee.employeeId} (${fullName}) was ${newStatus.toLowerCase()} by ${adminName}`\n          },\n          status: 'Completed',\n          datetimecreated: new Date().toISOString(),\n          lastModifiedDate: new Date().toISOString()\n        };\n        workflows.push(workflow);\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, request), {\n          type: (requestType === null || requestType === void 0 ? void 0 : requestType.name) || request.type,\n          items: items,\n          employee: employee ? {\n            id: employee.id,\n            employeeId: employee.employeeId,\n            fullName: fullName\n          } : null\n        }));\n      }\n      function deleteRequest() {\n        if (!isAuthenticated()) return unauthorized();\n        const requestId = idFromUrl();\n        const request = requests.find(x => x.id === requestId);\n        if (!request) return notFound();\n        if (request.employeeId !== currentAccount().id && !isAdmin()) return unauthorized();\n        // Delete request and its items\n        requests = requests.filter(x => x.id !== requestId);\n        requestItems = requestItems.filter(x => x.requestId !== requestId);\n        localStorage.setItem(requestsKey, JSON.stringify(requests));\n        localStorage.setItem(requestItemsKey, JSON.stringify(requestItems));\n        return ok();\n      }\n      // Employee functions\n      function getEmployees() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(employees.map(employee => {\n          const department = departments.find(d => d.id === employee.departmentId);\n          const account = accounts.find(a => a.id === employee.accountId);\n          // Format names with proper capitalization\n          const firstName = (account === null || account === void 0 ? void 0 : account.firstName) ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n          const lastName = (account === null || account === void 0 ? void 0 : account.lastName) ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n          return Object.assign(Object.assign({}, employee), {\n            employeeId: employee.employeeId,\n            fullName: `${firstName} ${lastName}`.trim(),\n            departmentName: (department === null || department === void 0 ? void 0 : department.name) || '',\n            department: department ? {\n              id: department.id,\n              name: department.name,\n              description: department.description\n            } : null,\n            account: account ? basicDetails(account) : null\n          });\n        }));\n      }\n      function getEmployeeById() {\n        if (!isAuthenticated()) return unauthorized();\n        const employeeId = idFromUrl();\n        const employee = employees.find(x => x.id === employeeId);\n        if (!employee) return notFound();\n        // Get fresh department data\n        const department = departments.find(d => d.id === employee.departmentId);\n        if (!department) return error('Department not found');\n        const account = accounts.find(a => a.id === employee.accountId);\n        const firstName = (account === null || account === void 0 ? void 0 : account.firstName) ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n        const lastName = (account === null || account === void 0 ? void 0 : account.lastName) ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n        // Return complete employee data with fresh relations\n        return ok(Object.assign(Object.assign({}, employee), {\n          employeeId: employee.employeeId,\n          fullName: `${firstName} ${lastName}`.trim(),\n          departmentName: department.name,\n          department: {\n            id: department.id,\n            name: department.name,\n            description: department.description\n          },\n          account: basicDetails(account)\n        }));\n      }\n      function createEmployee() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        // Log the received data for debugging\n        console.log('Received employee data:', body);\n        // Check if employee ID already exists\n        if (employees.find(x => x.employeeId === body.employeeId)) {\n          return error('Employee ID already exists');\n        }\n        // Validate department exists\n        const department = departments.find(d => d.id === Number(body.departmentId));\n        if (!department) return error('Department not found');\n        // Validate account exists and isn't already assigned to an employee\n        const account = accounts.find(a => a.id === Number(body.accountId));\n        if (!account) return error('Account not found');\n        if (employees.find(e => e.accountId === Number(body.accountId))) {\n          return error('Account is already assigned to another employee');\n        }\n        const employee = {\n          id: newEmployeeId(),\n          accountId: Number(body.accountId),\n          employeeId: body.employeeId,\n          departmentId: Number(body.departmentId),\n          position: body.position,\n          hireDate: body.hireDate,\n          status: body.status || 'Active',\n          createdDate: new Date().toISOString(),\n          lastModifiedDate: new Date().toISOString()\n        };\n        // Check each required field individually and log the result\n        const requiredFields = {\n          accountId: !!employee.accountId,\n          employeeId: !!employee.employeeId,\n          departmentId: !!employee.departmentId,\n          position: !!employee.position,\n          hireDate: !!employee.hireDate\n        };\n        console.log('Field validation results:', requiredFields);\n        // Check if any required field is missing\n        const missingFields = Object.entries(requiredFields).filter(([_, isValid]) => !isValid).map(([fieldName]) => fieldName);\n        if (missingFields.length > 0) {\n          return error(`Required fields are missing: ${missingFields.join(', ')}`);\n        }\n        // Format names\n        const firstName = account.firstName ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n        const lastName = account.lastName ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n        // Create workflow entry for new employee\n        const workflow = {\n          id: newWorkflowId(),\n          employeeId: employee.id,\n          type: 'Added',\n          details: {\n            task: `New employee ${employee.employeeId} was added`,\n            additionalInfo: `Added to ${department.name} department as ${employee.position}`\n          },\n          status: 'Completed',\n          createdDate: new Date().toISOString(),\n          lastModifiedDate: new Date().toISOString()\n        };\n        employees.push(employee);\n        workflows.push(workflow);\n        localStorage.setItem(employeesKey, JSON.stringify(employees));\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, employee), {\n          fullName: `${firstName} ${lastName}`.trim(),\n          departmentName: department.name,\n          department: {\n            id: department.id,\n            name: department.name,\n            description: department.description\n          }\n        }));\n      }\n      function updateEmployee() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const employeeId = idFromUrl();\n        const employeeIndex = employees.findIndex(x => x.id === employeeId);\n        if (employeeIndex === -1) return notFound();\n        const oldEmployee = employees[employeeIndex];\n        const updatedEmployee = Object.assign(Object.assign(Object.assign({}, oldEmployee), body), {\n          id: employeeId,\n          accountId: body.accountId ? Number(body.accountId) : oldEmployee.accountId,\n          departmentId: body.departmentId ? Number(body.departmentId) : oldEmployee.departmentId,\n          position: body.position || oldEmployee.position,\n          lastModifiedDate: new Date().toISOString()\n        });\n        // Validate department exists if changed\n        if (body.departmentId) {\n          const department = departments.find(d => d.id === updatedEmployee.departmentId);\n          if (!department) return error('Department not found');\n        }\n        // Validate account exists if changed\n        if (body.accountId) {\n          const account = accounts.find(a => a.id === updatedEmployee.accountId);\n          if (!account) return error('Account not found');\n        }\n        const department = departments.find(d => d.id === updatedEmployee.departmentId);\n        const account = accounts.find(a => a.id === updatedEmployee.accountId);\n        // Create workflow entry for updated employee\n        const workflow = {\n          id: newWorkflowId(),\n          employeeId: employeeId,\n          type: 'Updated',\n          details: {\n            task: `Employee ${employeeId} was updated`,\n            additionalInfo: `Updated in ${department.name} department`\n          },\n          status: 'Completed',\n          createdDate: new Date().toISOString(),\n          lastModifiedDate: new Date().toISOString()\n        };\n        // Update the employee at the correct index (instead of pushing and creating a duplicate)\n        employees[employeeIndex] = updatedEmployee;\n        workflows.push(workflow);\n        localStorage.setItem(employeesKey, JSON.stringify(employees));\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, updatedEmployee), {\n          departmentName: department.name,\n          department: {\n            id: department.id,\n            name: department.name,\n            description: department.description\n          },\n          account: basicDetails(account)\n        }));\n      }\n      function deleteEmployee() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const employeeId = idFromUrl();\n        const employeeIndex = employees.findIndex(x => x.id === employeeId);\n        if (employeeIndex === -1) return notFound();\n        const employee = employees[employeeIndex];\n        // Delete employee\n        employees = employees.filter(x => x.id !== employeeId);\n        localStorage.setItem(employeesKey, JSON.stringify(employees));\n        return ok(Object.assign(Object.assign({}, employee), {\n          status: 'Deleted'\n        }));\n      }\n      function transferEmployee() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const employeeId = idFromUrl();\n        // Find the employee index\n        const employeeIndex = employees.findIndex(x => x.id === employeeId);\n        if (employeeIndex === -1) {\n          console.error('Employee not found:', employeeId);\n          return notFound();\n        }\n        // Get the current employee\n        const employee = employees[employeeIndex];\n        const oldDepartmentId = employee.departmentId;\n        const newDepartmentId = Number(body.departmentId);\n        // Validate departments exist\n        const oldDepartment = departments.find(d => d.id === oldDepartmentId);\n        const newDepartment = departments.find(d => d.id === newDepartmentId);\n        if (!oldDepartment || !newDepartment) {\n          console.error('Department not found. Old:', oldDepartmentId, 'New:', newDepartmentId);\n          return error('Department not found');\n        }\n        // Don't do anything if the department hasn't changed\n        if (oldDepartmentId === newDepartmentId) {\n          console.log('Employee already in department:', newDepartmentId);\n          return error('Employee is already in this department');\n        }\n        console.log('Transferring employee', employee.employeeId, 'from', oldDepartment.name, 'to', newDepartment.name);\n        // Update the employee's department\n        employees[employeeIndex] = Object.assign(Object.assign({}, employee), {\n          departmentId: newDepartmentId,\n          lastModifiedDate: new Date().toISOString()\n        });\n        // Get employee account for name\n        const account = accounts.find(a => a.id === employee.accountId);\n        const firstName = (account === null || account === void 0 ? void 0 : account.firstName) ? account.firstName.charAt(0).toUpperCase() + account.firstName.slice(1).toLowerCase() : '';\n        const lastName = (account === null || account === void 0 ? void 0 : account.lastName) ? account.lastName.charAt(0).toUpperCase() + account.lastName.slice(1).toLowerCase() : '';\n        // Create workflow entry for transfer\n        const workflow = {\n          id: newWorkflowId(),\n          employeeId: employeeId,\n          type: 'Transferred',\n          details: {\n            task: `Employee ${employee.employeeId} was transferred`,\n            additionalInfo: `From ${oldDepartment.name} to ${newDepartment.name} department`\n          },\n          status: 'Completed',\n          createdDate: new Date().toISOString(),\n          lastModifiedDate: new Date().toISOString()\n        };\n        workflows.push(workflow);\n        // Save changes\n        localStorage.setItem(employeesKey, JSON.stringify(employees));\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        console.log('Transfer completed successfully');\n        return ok(Object.assign(Object.assign({}, employees[employeeIndex]), {\n          fullName: `${firstName} ${lastName}`.trim(),\n          departmentName: newDepartment.name,\n          department: {\n            id: newDepartment.id,\n            name: newDepartment.name,\n            description: newDepartment.description\n          }\n        }));\n      }\n      // Department functions\n      function getDepartments() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(departments.map(department => {\n          return Object.assign(Object.assign({}, department), {\n            id: department.id.toString(),\n            name: department.name,\n            description: department.description\n          });\n        }));\n      }\n      function getDepartmentById() {\n        if (!isAuthenticated()) return unauthorized();\n        const departmentId = idFromUrl();\n        const department = departments.find(x => x.id === departmentId);\n        if (!department) return notFound();\n        return ok(Object.assign(Object.assign({}, department), {\n          id: department.id.toString(),\n          name: department.name,\n          description: department.description\n        }));\n      }\n      function createDepartment() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const department = body;\n        // Validate department name is unique\n        if (departments.find(x => x.name === department.name)) {\n          return error('Department name already exists');\n        }\n        // Assign department id and save\n        department.id = newDepartmentId();\n        departments.push(department);\n        localStorage.setItem(departmentsKey, JSON.stringify(departments));\n        return ok(Object.assign(Object.assign({}, department), {\n          id: department.id.toString()\n        }));\n      }\n      function updateDepartment() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const departmentId = idFromUrl();\n        const departmentIndex = departments.findIndex(x => x.id === departmentId);\n        if (departmentIndex === -1) return notFound();\n        const oldDepartment = departments[departmentIndex];\n        const updatedDepartment = Object.assign(Object.assign(Object.assign({}, oldDepartment), body), {\n          id: departmentId,\n          lastModifiedDate: new Date().toISOString()\n        });\n        // Validate department name is unique\n        if (departments.find(x => x.name === updatedDepartment.name && x.id !== updatedDepartment.id)) {\n          return error('Department name already exists');\n        }\n        departments.push(updatedDepartment);\n        localStorage.setItem(departmentsKey, JSON.stringify(departments));\n        return ok(Object.assign(Object.assign({}, updatedDepartment), {\n          id: updatedDepartment.id.toString()\n        }));\n      }\n      function deleteDepartment() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const departmentId = idFromUrl();\n        const departmentIndex = departments.findIndex(x => x.id === departmentId);\n        if (departmentIndex === -1) return notFound();\n        const department = departments[departmentIndex];\n        // Delete department\n        departments = departments.filter(x => x.id !== departmentId);\n        localStorage.setItem(departmentsKey, JSON.stringify(departments));\n        return ok(Object.assign(Object.assign({}, department), {\n          status: 'Deleted'\n        }));\n      }\n      // Position functions\n      function getPositions() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(positions.map(position => {\n          return Object.assign(Object.assign({}, position), {\n            id: position.id.toString(),\n            name: position.name,\n            description: position.description\n          });\n        }));\n      }\n      function getPositionById() {\n        if (!isAuthenticated()) return unauthorized();\n        const positionId = idFromUrl();\n        const position = positions.find(x => x.id === positionId);\n        if (!position) return notFound();\n        return ok(Object.assign(Object.assign({}, position), {\n          id: position.id.toString(),\n          name: position.name,\n          description: position.description\n        }));\n      }\n      function createPosition() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const position = body;\n        // Validate position name is unique\n        if (positions.find(x => x.name === position.name)) {\n          return error('Position name already exists');\n        }\n        // Assign position id and save\n        position.id = newPositionId();\n        positions.push(position);\n        localStorage.setItem(positionsKey, JSON.stringify(positions));\n        return ok(Object.assign(Object.assign({}, position), {\n          id: position.id.toString()\n        }));\n      }\n      function updatePosition() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const positionId = idFromUrl();\n        const positionIndex = positions.findIndex(x => x.id === positionId);\n        if (positionIndex === -1) return notFound();\n        const oldPosition = positions[positionIndex];\n        const updatedPosition = Object.assign(Object.assign(Object.assign({}, oldPosition), body), {\n          id: positionId,\n          lastModifiedDate: new Date().toISOString()\n        });\n        // Validate position name is unique\n        if (positions.find(x => x.name === updatedPosition.name && x.id !== updatedPosition.id)) {\n          return error('Position name already exists');\n        }\n        positions.push(updatedPosition);\n        localStorage.setItem(positionsKey, JSON.stringify(positions));\n        return ok(Object.assign(Object.assign({}, updatedPosition), {\n          id: updatedPosition.id.toString()\n        }));\n      }\n      function deletePosition() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const positionId = idFromUrl();\n        const positionIndex = positions.findIndex(x => x.id === positionId);\n        if (positionIndex === -1) return notFound();\n        const position = positions[positionIndex];\n        // Delete position\n        positions = positions.filter(x => x.id !== positionId);\n        localStorage.setItem(positionsKey, JSON.stringify(positions));\n        return ok(Object.assign(Object.assign({}, position), {\n          status: 'Deleted'\n        }));\n      }\n      // Request type functions\n      function getRequestTypes() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(requestTypes.map(type => {\n          return Object.assign(Object.assign({}, type), {\n            id: type.id.toString(),\n            name: type.name,\n            description: type.description\n          });\n        }));\n      }\n      function getRequestTypeById() {\n        if (!isAuthenticated()) return unauthorized();\n        const typeId = idFromUrl();\n        const type = requestTypes.find(x => x.id === typeId);\n        if (!type) return notFound();\n        return ok(Object.assign(Object.assign({}, type), {\n          id: type.id.toString(),\n          name: type.name,\n          description: type.description\n        }));\n      }\n      function createRequestType() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const type = body;\n        // Validate request type name is unique\n        if (requestTypes.find(x => x.name === type.name)) {\n          return error('Request type name already exists');\n        }\n        // Assign request type id and save\n        type.id = newRequestTypeId();\n        requestTypes.push(type);\n        localStorage.setItem(requestTypesKey, JSON.stringify(requestTypes));\n        return ok(Object.assign(Object.assign({}, type), {\n          id: type.id.toString()\n        }));\n      }\n      function updateRequestType() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const typeId = idFromUrl();\n        const typeIndex = requestTypes.findIndex(x => x.id === typeId);\n        if (typeIndex === -1) return notFound();\n        const oldType = requestTypes[typeIndex];\n        const updatedType = Object.assign(Object.assign(Object.assign({}, oldType), body), {\n          id: typeId,\n          lastModifiedDate: new Date().toISOString()\n        });\n        // Validate request type name is unique\n        if (requestTypes.find(x => x.name === updatedType.name && x.id !== updatedType.id)) {\n          return error('Request type name already exists');\n        }\n        requestTypes.push(updatedType);\n        localStorage.setItem(requestTypesKey, JSON.stringify(requestTypes));\n        return ok(Object.assign(Object.assign({}, updatedType), {\n          id: updatedType.id.toString()\n        }));\n      }\n      function deleteRequestType() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const typeId = idFromUrl();\n        const typeIndex = requestTypes.findIndex(x => x.id === typeId);\n        if (typeIndex === -1) return notFound();\n        const type = requestTypes[typeIndex];\n        // Delete request type\n        requestTypes = requestTypes.filter(x => x.id !== typeId);\n        localStorage.setItem(requestTypesKey, JSON.stringify(requestTypes));\n        return ok(Object.assign(Object.assign({}, type), {\n          status: 'Deleted'\n        }));\n      }\n      // Workflow functions\n      function getWorkflows() {\n        if (!isAuthenticated()) return unauthorized();\n        // Sort workflows in descending order by creation date\n        const sortedWorkflows = [...workflows].sort((a, b) => {\n          const dateA = new Date(a.datetimecreated || a.createdDate);\n          const dateB = new Date(b.datetimecreated || b.createdDate);\n          return dateB.getTime() - dateA.getTime();\n        });\n        return ok(sortedWorkflows.map(workflow => {\n          // Get associated request if it exists\n          const request = workflow.requestId ? requests.find(r => r.id === workflow.requestId) : null;\n          // Get employee info\n          const employee = employees.find(e => e.id === workflow.employeeId);\n          // Format details appropriately with request number if available\n          let details = '';\n          if (typeof workflow.details === 'object') {\n            details = workflow.details.task || '';\n            if (workflow.details.additionalInfo) {\n              details += ` - ${workflow.details.additionalInfo}`;\n            }\n          } else {\n            details = workflow.details || '';\n          }\n          // Replace placeholders in details if needed\n          if (request && details.includes('#')) {\n            details = details.replace(/#(\\d+)/g, `#${request.id}`);\n          }\n          return {\n            id: workflow.id.toString(),\n            type: workflow.type,\n            details: details,\n            status: workflow.status,\n            datetimecreated: workflow.datetimecreated || workflow.createdDate,\n            requestId: workflow.requestId ? workflow.requestId.toString() : null,\n            employee: employee ? {\n              id: employee.id,\n              employeeId: employee.employeeId,\n              name: getEmployeeName(employee)\n            } : null\n          };\n        }));\n      }\n      function getWorkflowById() {\n        if (!isAuthenticated()) return unauthorized();\n        const workflow = workflows.find(x => x.id === idFromUrl());\n        if (!workflow) return notFound();\n        const details = typeof workflow.details === 'object' ? `${workflow.details.task}${workflow.details.additionalInfo ? ` - ${workflow.details.additionalInfo}` : ''}` : workflow.details || '';\n        return ok({\n          id: workflow.id.toString(),\n          type: workflow.type,\n          details: details,\n          status: workflow.status,\n          datetimecreated: workflow.datetimecreated || workflow.createdDate\n        });\n      }\n      function getWorkflowsByRequestId() {\n        if (!isAuthenticated()) return unauthorized();\n        const requestId = parseInt(url.split('/').pop());\n        console.log('Looking for workflows with requestId:', requestId);\n        const request = requests.find(x => x.id === requestId);\n        if (!request) {\n          console.log('Request not found with id:', requestId);\n          return notFound();\n        }\n        const requestWorkflows = workflows.filter(x => x.requestId === requestId);\n        console.log('Found workflows:', requestWorkflows.length);\n        // Sort workflows in descending order\n        const sortedWorkflows = [...requestWorkflows].sort((a, b) => {\n          const dateA = new Date(a.datetimecreated || a.createdDate);\n          const dateB = new Date(b.datetimecreated || b.createdDate);\n          return dateB.getTime() - dateA.getTime();\n        });\n        return ok(sortedWorkflows.map(workflow => {\n          // Get employee info\n          const employee = employees.find(e => e.id === workflow.employeeId);\n          // Format details appropriately with request number if available\n          let details = '';\n          if (typeof workflow.details === 'object') {\n            details = workflow.details.task || '';\n            if (workflow.details.additionalInfo) {\n              details += ` - ${workflow.details.additionalInfo}`;\n            }\n          } else {\n            details = workflow.details || '';\n          }\n          // Replace placeholders in details if needed\n          if (details.includes('#')) {\n            details = details.replace(/#(\\d+)/g, `#${requestId}`);\n          }\n          return {\n            id: workflow.id.toString(),\n            type: workflow.type,\n            details: details,\n            status: workflow.status,\n            datetimecreated: workflow.datetimecreated || workflow.createdDate,\n            requestId: requestId.toString(),\n            employee: employee ? {\n              id: employee.id,\n              employeeId: employee.employeeId,\n              name: getEmployeeName(employee)\n            } : null\n          };\n        }));\n      }\n      function createWorkflow() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        console.log('Received workflow data:', body);\n        const workflow = {\n          id: newWorkflowId(),\n          employeeId: body.employeeId,\n          type: body.type,\n          details: body.details,\n          status: body.status,\n          createdDate: new Date().toISOString(),\n          lastModifiedDate: new Date().toISOString()\n        };\n        // Validate required fields\n        const requiredFields = {\n          employeeId: !!workflow.employeeId,\n          type: !!workflow.type,\n          details: !!workflow.details,\n          status: !!workflow.status\n        };\n        console.log('Field validation results:', requiredFields);\n        // Check if any required field is missing\n        const missingFields = Object.entries(requiredFields).filter(([_, isValid]) => !isValid).map(([fieldName]) => fieldName);\n        if (missingFields.length > 0) {\n          return error(`Required fields are missing: ${missingFields.join(', ')}`);\n        }\n        // Validate employee exists\n        const employee = employees.find(e => e.id === workflow.employeeId);\n        if (!employee) return error('Employee not found');\n        employees.push(workflow);\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, workflow), {\n          employee: employee ? Object.assign(Object.assign({}, employee), {\n            employeeId: employee.employeeId\n          }) : null\n        }));\n      }\n      function updateWorkflow() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const workflowId = idFromUrl();\n        const workflowIndex = workflows.findIndex(x => x.id === workflowId);\n        if (workflowIndex === -1) return notFound();\n        const oldWorkflow = workflows[workflowIndex];\n        const updatedWorkflow = Object.assign(Object.assign(Object.assign({}, oldWorkflow), body), {\n          id: workflowId,\n          lastModifiedDate: new Date().toISOString()\n        });\n        // Validate employee exists\n        const employee = employees.find(e => e.id === updatedWorkflow.employeeId);\n        if (!employee) return error('Employee not found');\n        employees.push(updatedWorkflow);\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, updatedWorkflow), {\n          employee: employee ? Object.assign(Object.assign({}, employee), {\n            employeeId: employee.employeeId\n          }) : null\n        }));\n      }\n      function updateWorkflowStatus() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const workflowId = idFromUrl();\n        const workflow = workflows.find(x => x.id === workflowId);\n        if (!workflow) return notFound();\n        const newStatus = body.status;\n        Object.assign(workflow, {\n          status: newStatus,\n          lastModifiedDate: new Date().toISOString()\n        });\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, workflow), {\n          status: newStatus\n        }));\n      }\n      function deleteWorkflow() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const workflowId = idFromUrl();\n        const workflowIndex = workflows.findIndex(x => x.id === workflowId);\n        if (workflowIndex === -1) return notFound();\n        const workflow = workflows[workflowIndex];\n        const employee = employees.find(e => e.id === workflow.employeeId);\n        // Delete workflow\n        workflows = workflows.filter(x => x.id !== workflowId);\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, workflow), {\n          employee: employee ? Object.assign(Object.assign({}, employee), {\n            employeeId: employee.employeeId\n          }) : null\n        }));\n      }\n      function deleteWorkflowItem() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const workflowId = idFromUrl();\n        const workflow = workflows.find(x => x.id === workflowId);\n        if (!workflow) return notFound();\n        // Delete workflow item\n        workflows = workflows.filter(x => x.id !== workflowId);\n        localStorage.setItem(workflowsKey, JSON.stringify(workflows));\n        return ok(Object.assign(Object.assign({}, workflow), {\n          status: 'Deleted'\n        }));\n      }\n      function createAccount() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          return error('Email already exists');\n        }\n        account.id = newAccountId();\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(basicDetails(account));\n      }\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        const accountId = idFromUrl();\n        const account = accounts.find(x => x.id === accountId);\n        if (!account) return notFound();\n        if (account.id !== currentAccount().id && !isAdmin()) return unauthorized();\n        // Only allow admins to update role\n        if (!isAdmin()) {\n          delete body.role;\n        }\n        // If email is being changed, make sure it's not already taken\n        if (body.email && body.email !== account.email && accounts.find(x => x.email === body.email)) {\n          return error('Email already exists');\n        }\n        Object.assign(account, body);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(basicDetails(account));\n      }\n      function deleteAccount() {\n        if (!isAuthenticated() || !isAdmin()) return unauthorized();\n        const accountId = idFromUrl();\n        const account = accounts.find(x => x.id === accountId);\n        if (!account) return notFound();\n        if (account.id === currentAccount().id) return error('You cannot delete your own account');\n        accounts = accounts.filter(x => x.id !== accountId);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        // Return ok response regardless of whether account exists\n        // This prevents email enumeration\n        if (!account) return ok();\n        // Create reset token that expires after 24 hours\n        account.resetToken = {\n          token: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15),\n          expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\n        };\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // In a real app, this would send an email\n        console.log('RESET TOKEN CREATED FOR EMAIL:', email);\n        // No need to show an alert here as the component will handle it\n        return ok();\n      }\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => x.resetToken && x.resetToken.token === token && new Date(x.resetToken.expires) > new Date());\n        if (!account) return error('Invalid or expired token');\n        return ok();\n      }\n      function resetPassword() {\n        const {\n          token,\n          password,\n          confirmPassword\n        } = body;\n        // Validate\n        if (!token || !password || !confirmPassword) {\n          return error('All fields are required');\n        }\n        if (password !== confirmPassword) {\n          return error('Passwords must match');\n        }\n        const account = accounts.find(x => x.resetToken && x.resetToken.token === token && new Date(x.resetToken.expires) > new Date());\n        if (!account) return error('Invalid or expired token');\n        // Update password and remove reset token\n        account.password = password;\n        delete account.resetToken;\n        // Auto verify email if not already verified\n        if (!account.isVerified) {\n          account.isVerified = true;\n        }\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n    }\n  }\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n  };\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport const fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}